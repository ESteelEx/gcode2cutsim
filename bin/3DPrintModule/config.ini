[MESH]
;fileName =Z:\07_Products\06_3D-Printing\01_Sample Parts\basic_geometric_elements.stl
;fileName =AachenerDom_Platte_fuer_Kurt.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\Aachen Dom\AachenerDom_Platte_fuer_Kurt_trimmed.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\OverhangTests\2.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\PrinterTesting\free_form.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\PrinterTesting\ctrlV_3D_test.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\sphere.stl
;fileName =Z:\07_Products\06_3D-Printing\01_Sample Parts\Organic_lampshade\organiska_lampan.STL
;filename = Z:\07_Products\06_3D-Printing\01_Sample Parts\MWLogo\MW_Logo.stl
;filename = Z:\07_Products\06_3D-Printing\01_Sample Parts\cylinder_in_cylinder.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\PrinterTesting\Calib3.stl
fileName = rect_50x50x20.stl

; (0.0 ... n factor) Scales the object. Scaling is applied first.
scaleX = 1
; (0.0 ... n factor)
scaleY = 1
; (0.0 ... n factor)
scaleZ = 1
; (0.0 ... n in mm) Translation is applied after centering
translationX = 0.0
; (0.0 ... n in mm) 
translationY = 0.0
; (0.0 ... n in mm)
translationZ = 0.0
; (1/0) Centers object in bed
center = 1

[FANSPEED]
; (1/0) activate fan usage
activate = 0
; (0...n) fan is activated on this layer
startLayer = 0
; (0...n) fan is is turned off on this layer
endLayer = 10000
; (0...n) fan accalerates from minSpeed to maxSped in n layer
accelarationLayer = 4
; (0...255) startSpeed
minSpeed = 0
; (0...254)
maxSpeed = 0

; Settings for the ClipperLib used internally for polygon operations
; Differnce between MITER and ROUND offsettype is explained here:
; http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/JoinType.htm
[CLIPPER]
; ClipperLib uses 64bit integer internally, this factor scales doubles to integer.
scale = 1048576
; RoundPrecision is http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Classes/ClipperOffset/Properties/ArcTolerance.htm
; It is used when using offsetType = ROUND
roundPrecision = 1024.0
; MiterLimit is http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Classes/ClipperOffset/Properties/MiterLimit.htm
; It is used when using offsetType = MITER
miterLimit = 1.0

[SLICER]
; (0.0 ... n in mm) height of first layer 
firstLayerHeight = 0.3
; (0.0 ... n in mm) distance between further layers
layerHeight = 0.25
; (0.0 ... n in mm) Slicer can automaticaly handle small gaps in the mesh.
gapTolerance = 0.001
; (0 ... n) Multiple slices are applied between 2 layers and are accumulated 
correctionSlices = 0
; (0.0 ... n in mm) Filters/smooths resulting polylines after slicing. Every segment will have at least filterTolerance length
filterTolerance = 0.01

[INFILL]
; (0 ... n) detected floors are filled solid and N-1 consecutive layers above (fill solid)
solidFloorLayers = 2
; (0 ... n) detected roofs are filled solid and N-1 consecutive layers below (fill solid)
solidRoofLayers = 2
; (1/0) handle most upper layer as roof (fill solid)
mostUpperLayerIsRoof = 0
; (1/0) handle most lower layer as roof  (fill solid)
mostLowerLayerIsFloor = 0
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm)  Solid infills are enlarged by this factor to avoid tiny sparse areas.
solidEnlargement = 0.0
; (0.0 ... n in mm) extrusion line width
lineWidth = 0.48
; (0.0 ... n in mm) distance between extrusion lines when filling with sparse pattern
spacing = 1.34
; (0.0 ... n)
orientationX = 1.0
; (0.0 ... n)
orientationY = 1.0
; (0.0 ... 1.0) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
lineOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 900;
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm^3/min) 
extrusionrate = 3



; NOT related to lineOverlap, perimeterOverlap.
; This settings are used to detect overhangs and undercuts, which are used to detect floors, roofs and generate support base contours.
[OVERLAP]
; (0.0 ... n in mm) Allowed overlap. Detected overlap is reduced by this amount. 
allowedOverlap = 0
; (0.0 .... 90.0 in °) Allowed overlap angle. With current layer height an allowedOverlap is calcaulted. Maximum of allowedOverlap and the calculated value is used.
allowedOverlapAngle = 70
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm^2) Area with less then this size are filtered out.
minArea = 0.01
; (0.0 ... n in mm) Area with less then this width in X/Y are filtered out.
minWidth = 0.0
; (0.0 ... n in mm)
maxGapWidth = 0.00

[WALL]
; (0.0 ... n in mm) extrusion line width of most outer wallline
firstPerimeterWidth = 0.6
; (0.0 ... n in mm) extrusion line width
perimeterWidth = 0.6
; (0 ... n)
desiredPerimeterCount = 3
; (0.0 ... 1.0) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm) Perimeters are opened between start and end point by this distance
openDistance = 0.05
; (MITER/ROUND)
offsetType = MITER
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... n in mm/min)
feedrate = 600
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm^3/min) 
extrusionrate = 3

[SKIRT]
; (1/0)
create = 0
; (0 ... n) number of skirt lines
desiredPerimeterCount = 3
; (0.0 ... n in mm) distance of skirt to the object
distance =  15.00
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm) extrusion line width 
perimeterWidth = 0.48
; (0.0 ... n in mm) skirt contours are merged by enlarging and shrinking before perimeters are generated
mergeDistance = 0.0
; (MITER/ROUND)
mergeOffsetType = MITER
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 1500
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm^3/min) 
extrusionrate = 3

[BRIM]
; (1/0)
create = 0
; (0 ... n) number of brim lines
desiredPerimeterCount = 3
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm) extrusion line width 
perimeterWidth = 0.48
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 900
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm^3/min) 
extrusionrate = 3

[GCODE]
; filename of GCode output file
fileName = rect_50x50x20.gcode
; (1/0) comments in GCode File
comments = 1
; (0 ... n) number of digits after dot in gcode file
precision = 6
; (0.0 ... n in mm) polyline reduction on final extrusion paths
outputFilterTolerance = 0.01


[MACHINE]
; (0.0 ... n in mm)  use retraction if the traval distance for a non-extrusion exceeds this threshhold
retractionThreshold = 1.5
; (0.0 ... n in mm) 
bedX = 230
; (0.0 ... n in mm)
bedY = 225
; (0.0 ... n in mm) currently not implemented, current extrusion amounts are volumetric. this will be needed for non volumetric extrusion
materialDiameter = 2.85
; (0 ... n in °)
bedTemperature = 230
; (0.0 ... n in mm) The distance that needs to be exceeded to perform a rapidmove
rapidMoveDistanceThreshhold = 0.0
; (0/1)
constantExtrusionRate = 0


[DEBUG]
; (1/0)
createLogFile = 0

[SUPPORT]
; (1/0)
create = 1
; (0.0 ... n in mm) 
overhangAccumulationDistance = 0.0
; (0.0 ... n in mm) support towers have a minimum distance to the object in areas where they are not supporting
minObjectDistance = 0.0
; (ROUND/MITER)
offsetType = MITER
; (0.0 ... n in mm) size of the tower base square
towerWidth = 2
; (~0.42*towerWidth ... n in mm) minimum distance between two towers
minTowerDistance = 4
; (0.0 ... n in mm) extrusion line width of tower perimeters
towerLineWidth = 0.48
; (0.0 ... n in mm^2) when the head of tower shrinks due to contact with the object, the tower stops growing, if the area size goes below this limit
towerHeadMinArea = 1.0
; (5.0 ... 45 in °) tower shrinks with this angle as soon as contact which the object exists
towerHeadAngle = 10
; (0.0 ... n in mm/min)
feedrate = 600
; (0.0 ... n in mm/min)
rapidFeedrate = 2400

[SORT]
; (0/1) print perimeters of a part before its infill
wallsBeforeInfills = 1
; (0/1) print all perimeters with related infills
infillAndWallTogether = 0



