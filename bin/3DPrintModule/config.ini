[DEBUG]
debugView = 1
closeConsole = 1

[GCODE]
; filename of GCode output file
fileName = C:\Users\lars\Desktop\3D Drucker\free_form.gcode
; (1/0) comments in GCode File
comments = 1
; (0 ... n) number of digits after dot in gcode file
precision = 6
; (0.0 ... n in mm) polyline reduction/filtering on final extrusion paths
filterTolerance = 0.01

[MESH]
;fileName =Z:\07_Products\06_3D-Printing\01_Sample Parts\basic_geometric_elements.stl
;fileName =AachenerDom_Platte_fuer_Kurt.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\Aachen Dom\AachenerDom_Platte_fuer_Kurt_trimmed.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\OverhangTests\2.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\PrinterTesting\free_form.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\PrinterTesting\ctrlV_3D_test_NetFabbFixed.stl
fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\sphere.stl
;fileName =Z:\07_Products\06_3D-Printing\01_Sample Parts\Organic_lampshade\organiska_lampan.STL
;filename = Z:\07_Products\06_3D-Printing\01_Sample Parts\MWLogo\MW_Logo.stl
;filename = Z:\07_Products\06_3D-Printing\01_Sample Parts\cylinder_in_cylinder.stl
;fileName = Z:\07_Products\06_3D-Printing\01_Sample Parts\PrinterTesting\Calib3.stl

; (0.0 ... n factor) Scales the object. Scaling is applied first.
scaleX = 1
; (0.0 ... n factor)
scaleY = 1
; (0.0 ... n factor)
scaleZ = 1
; (0.0 ... n in mm) Translation is applied after centering
translationX = 0.0
; (0.0 ... n in mm) 
translationY = 0.0
; (0.0 ... n in mm)
translationZ = 0.0
; (1/0) Centers object in bed
center = 1

[FANSPEED]
; (1/0) activate fan usage
activate = 1
; (0...n) fan is truned on this layer
startLayer = 2
; (0...n) fan is is turned off on layerCount-endLayer
endLayer = 3
; (0...n)
; fan accalerates from [startLayer, startLayer+accelarationLayer] from minSpeed to maxSpeed
; fan decelerates from [layerCount-endLayer-accelarationLayer, layerCount-endLayer] from maxSpeed to minSpeed
accelarationLayer = 3
; (0...254)
minSpeed = 0
; (0...254)
maxSpeed = 254


[SLICER]
; (0.0 ... n in mm) height of first layer 
firstLayerHeight = 0.3
; (0.0 ... n in mm) distance between further layers
layerHeight = 0.2
; (0.0 ... n in mm) Slicer can automaticaly handle small gaps in the mesh.
gapTolerance = 0.1
; (0 ... n) Multiple slices are applied between 2 layers and are accumulated 
correctionSlices = 0
; (0.0 ... n in mm) Filters/smooths resulting polylines after slicing. Every segment will have at least filterTolerance length
filterTolerance = 0.01

[INFILL]
; (0 ... n) detected floors are filled solid and N-1 consecutive layers above (fill solid)
solidFloorLayers = 2
; (0 ... n) detected roofs are filled solid and N-1 consecutive layers below (fill solid)
solidRoofLayers = 2
; (1/0) handle most upper layer as roof (fill solid)
mostUpperLayerIsRoof = 1
; (1/0) handle most lower layer as roof  (fill solid)
mostLowerLayerIsFloor = 1
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm)  Solid infills are enlarged by this factor to avoid tiny sparse areas.
solidEnlargement = 0.0
; (0.0 ... n in mm) extrusion line width
lineWidth = 0.48
; (0.0 ... n in mm) distance between extrusion lines when filling with sparse pattern
spacing = 1.34
; (0.0 ... n)
orientationX = 1.0
; (0.0 ... n)
orientationY = 1.0
; (0.0 ... 1.0) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
lineOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 900;
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm/min) 
extrusionrate = 3



; NOT related to lineOverlap, perimeterOverlap.
; This settings are used to detect overhangs and undercuts, which are used to detect floors, roofs and generate support base contours.
[OVERHANG]
; (0.0 ... n in mm) Allowed overlap. Detected overlap is reduced by this amount. 
allowedOverlap = 0
; (0.0 .... 90.0 in °) Allowed overlap angle. With current layer height an allowedOverlap is calcaulted. Maximum of allowedOverlap and the calculated value is used.
allowedOverlapAngle = 30
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm^2) Area with less then this size are filtered out.
minArea = 0.01
; (0.0 ... n in mm) Area with less then this width in X/Y are filtered out.
minWidth = 0.0
; (0.0 ... n in mm)
maxGapWidth = 0.00
;(0.0 ... n in mm)
outerOverlapTolerance = 0.001

[WALL]
; (0.0 ... n in mm) extrusion line width of most outer wallline
firstPerimeterWidth = 0.6
; (0.0 ... n in mm) extrusion line width
perimeterWidth = 0.3
; (0 ... n)
desiredPerimeterCount = 2
; (0.0 ... 1.0) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm) Perimeters are opened between start and end point by this distance
openDistance = 0.05
; (MITER/ROUND)
offsetType = MITER
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... n in mm/min)
feedrate = 600
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 1800
; (0.0 ... n in mm/min) 
extrusionrate = 3

[SKIRT]
; (1/0)
create = 1
; (0 ... n) number of skirt lines
desiredPerimeterCount = 3
; (0.0 ... n in mm) distance of skirt to the object
distance =  15.00
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm) extrusion line width 
perimeterWidth = 0.48
; (0.0 ... n in mm) skirt contours are merged by enlarging and shrinking before perimeters are generated
mergeDistance = 0.0
; (MITER/ROUND)
mergeOffsetType = MITER
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 1500
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm/min) 
extrusionrate = 3

[BRIM]
; (1/0)
create = 0
; (0 ... n) number of brim lines
desiredPerimeterCount = 3
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm) extrusion line width 
perimeterWidth = 0.48
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 900
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm/min) 
extrusionrate = 3


[MACHINE]
; (0.0 ... n in mm)  use retraction if the traval distance for a non-extrusion exceeds this threshhold
retractionThreshold = 20
; (0.0 ... n in mm) 
bedX = 230
; (0.0 ... n in mm)
bedY = 225
; (0.0 ... n in mm) currently not implemented, current extrusion amounts are volumetric. this will be needed for non volumetric extrusion
materialDiameter = 2.85
; (0 ... n in °)
; (0.0 ... n in mm) The distance that needs to be exceeded to perform a rapidmove instead of normal move
bedTemperature = 230
rapidMoveDistanceThreshold = 0.0
; (0/1)
constantExtrusionRate = 0


[SUPPORT]
; (1/0)
create = 1
; (0.0 ... n in mm) 
overhangAccumulationDistance = 2.0
; (0.0 ... n in mm) support towers have a minimum distance to the object in areas where they are not supporting
minObjectDistance = 0
; (ROUND/MITER)
offsetType = MITER
; (0.0 ... n in mm) size of the tower base square
towerWidth = 0.5
; (~0.42*towerWidth ... n in mm) minimum distance between two towers
minTowerDistance = 0
; (0.0 ... n in mm) extrusion line width of tower perimeters
towerLineWidth = 0.48
; (0.0 ... n in mm^2) when the head of tower shrinks due to contact with the object, the tower stops growing, if the area size goes below this limit
towerMinArea = 1.0
; (0.0 ... n in mm/min)
feedrate = 900
; (0.0 ... n in mm/min)
travelFeedrate = 1200
; (0.0 ... n in mm/min)
rapidFeedrate = 2400
; (0.0 ... n in mm/min) 
extrusionrate = 3
; (0.0 ... n in mm) tower head get shrinked by this offset each layer while (possibly) reaching the object. To small value might shrink the head to 0 area before it has contact.
towerShrinking = 0.125
; (0 ... n ) when tower reaches object, it will stat shrinking at contactLayer - towerShrinkVerticalDistance
towerShrinkVerticalDistance = 3
; ( 0 ... n)
headContactLayer = 3
; ( 0 ... n)
footContactLayer = 6
