[MESH]
; define file name
;fileName = cylinder_rotated.stl
fileName = sphere.stl
; (0.0 ... n factor) Scales the object. Scaling is applied first.
scaleX = 5
; (0.0 ... n factor)
scaleY = 5
; (0.0 ... n factor)
scaleZ = 5
; (0.0 ... n in mm) Translation is applied after centering
translationX = 0.0
; (0.0 ... n in mm) 
translationY = 0.0
; (0.0 ... n in mm)
translationZ = 0.0
; (1/0) Centers object in bed
center = 1

[FANSPEED]
; (0...n) Fan is activated on this layer
startLayer = 0
; (0...n) Fan is is turned off on this layer
endLayer = 10000
; (0...n) Fan accalerates from minSpeed to maxSped in n layer
accelarationLayer = 4
; (0...255) startSpeed
minSpeed = 100
; (0...254)
maxSpeed = 254

; Settings for the ClipperLib used internally for polygon operations
; Differnce between MITER and ROUND offsettype is explained here:
; http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/JoinType.htm
[CLIPPER]
; ClipperLib uses 64bit integer internally, this factor scales doubles to integer.
scale = 1048576
; RoundPrecision is http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Classes/ClipperOffset/Properties/ArcTolerance.htm
; It is used when using offsetType = ROUND
roundPrecision = 1024.0
; MiterLimit is http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Classes/ClipperOffset/Properties/MiterLimit.htm
; It is used when using offsetType = MITER
miterLimit = 1.0

[SLICER]
; (0.0 ... n in mm) height of first layer 
firstLayerHeight = 0.3
; (0.0 ... n in mm) distance between further layers
layerHeight = 0.2
; (0.0 ... n in mm) Slicer can automaticaly handle small gaps in the mesh.
gapTolerance = 0.001
; (0 ... n) Multiple slices are applied between 2 layers and are accumulated 
correctionSlices = 0
; (0.0 ... n in mm) Filters/smooths resulting polylines after slicing. Every segment will have at least filterTolerance length
filterTolerance = 0.01

[INFILL]
; (0 ... n) detected floors are filled solid and N-1 consecutive layers above (fill solid)
solidFloorLayers = 3
; (0 ... n) detected roofs are filled solid and N-1 consecutive layers below (fill solid)
solidRoofLayers = 3
; (1/0) handle most upper layer as roof (fill solid)
mostUpperLayerIsRoof = 1
; (1/0) handle most lower layer as roof  (fill solid)
mostLowerLayerIsFloor = 1
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm)  Solid infills are enlarged by this factor to avoid tiny sparse areas.
solidEnlargement = 5.0
; (0.0 ... n in mm) extrusion line width
lineWidth = 0.48
; (0.0 ... n in mm) distance between extrusion lines when filling with sparse pattern
spacing = 1.34
; (0.0 ... n)
orientationX = 1.0
; (0.0 ... n)
orientationY = 1.0
; (0.0 ... n in mm/min)
feedrate = 900;
; (0.0 ... 1.0) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
lineOverlap = 0.2

; NOT related to lineOverlap, perimeterOverlap.
; This settings are used to detect overhangs and undercuts, which are used to detect floors, roofs and generate support base contours.
[OVERLAP]
; (0.0 ... n in mm) Allowed overlap. Detected overlap is reduced by this amount. 
allowedOverlap = 0
; (0.0 .... 90.0 in °) Allowed overlap angle. With current layer height an allowedOverlap is calcaulted. Maximum of allowedOverlap and the calculated value is used.
allowedOverlapAngle = 30
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm^2) Area with less then this size are filtered out.
minAreaFactor = 0.05
; (0.0 ... n in mm) Area with less then this width in X/Y are filtered out.
minWidth = 0.01

[WALL]
; (0.0 ... n in mm) extrusion line width of most outer wallline
firstPerimeterWidth = 0.42
; (0.0 ... n in mm) extrusion line width
perimeterWidth = 0.48
; (0 ... n)
desiredPerimeterCount = 3
; (0.0 ... 1.0) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (MITER/ROUND)
offsetType = MITER
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... n in mm/min)
feedrate = 900


[SKIRT]
; (1/0)
create = 0
; (0 ... n) number of skirt lines
desiredPerimeterCount = 3
; (0.0 ... n in mm) distance of skirt to the object
distance =  5.00
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm) extrusion line width 
perimeterWidth = 0.48
; (0.0 ... n in mm) skirt contours are merged by enlarging and shrinking before perimeters are generated
mergeDistance = 0.0
; (MITER/ROUND)
mergeOffsetType = MITER
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 1500

[BRIM]
; (1/0)
create = 0
; (0 ... n) number of brim lines
desiredPerimeterCount = 3
; (MITER/ROUND)
offsetType = MITER
; (0.0 ... n in mm) extrusion line width 
perimeterWidth = 0.48
; (1/0)
selfIntersectionRemoval = 1
; (0.0 ... 1) in % See http://manual.slic3r.org/advanced/flow-math for the idea behind overlap
perimeterOverlap = 0.2
; (0.0 ... n in mm/min)
feedrate = 900

[GCODE]
; filename of GCode output file
fileName = OH_test.gcode
; (1/0) comments in GCode File
comments = 1
; (0 ... n) number of digits after dot in gcode file
precision = 6
; (0.0 ... n in mm) polyline reduction on final extrusion paths
outputFilterTolerance = 0.01


[MACHINE]
; (0.0 ... n in mm)  use retraction if the traval distance for a non-extrusion exceeds this threshhold
retractionThreshold = 1.5
; (0.0 ... n in mm) 
bedX = 230
; (0.0 ... n in mm)
bedY = 225
; (0.0 ... n in mm) currently not implemented, current extrusion amounts are volumetric. this will be needed for non volumetric extrusion
materialDiameter = 2.85
; (0 ... n in °)	
bedTemperature = 230
bedTemperature = 230

[DEBUG]
; (1/0)
createLogFile = 0

[SUPPORT]
; (1/0)
create = 1
; (0.0 ... n in mm) 
overhangAccumulationDistance = 1
; (0.0 ... n in mm) support towers have a minimum distance to the object in areas where they are not supporting
minObjectDistance = 0
; (ROUND/MITER)
offsetType = MITER
; (0.0 ... n in mm) size of the tower base square
towerWidth = 1.2
; (0.0 ... n in mm) distance between the multiple towers
minTowerDistance = 1.2
; (0.0 ... n in mm) extrusion line width of tower perimeters
towerLineWidth = 0.48
; (0.0 ... n in mm^2) when the top of tower shrinks due to contact with the object, the tower stops growing, if the area size goes below this limit
towerMinArea = 0.01
; (5.0 ... 45 in °) tower shrinks with this angle as soon as contact which the object exists
towerHeadAngle = 10
; (0.0 ... n in mm/min)
feedrate = 600

[SORT]
; (0/1) print perimeters of a part before its infill
wallsBeforeInfills = 1
; (0/1) print all perimeters with related infills
infillAndWallTogether = 0



